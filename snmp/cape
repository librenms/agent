#!/usr/bin/env perl

use strict;
use warnings;
use Getopt::Long;
use File::ReadBackwards;
use JSON;
use Config::Tiny;
use DBI;
use Time::Piece;
use File::Slurp;

sub version {
	print "cape v. 0.0.1\n";
}

sub help {
	&version;

	print '

-c <ini>     Config INI file.
             Default: /usr/local/etc/cape_extend.ini
';
}

# get the commandline options
my $help     = 0;
my $version  = 0;
my $ini_file = '/usr/local/etc/cape_extend.ini';
Getopt::Long::Configure('no_ignore_case');
Getopt::Long::Configure('bundling');
GetOptions(
	'version' => \$version,
	'v'       => \$version,
	'help'    => \$help,
	'h'       => \$help,
	'i=s'     => \$ini_file,
);

# print version or help if requested
if ($help) {
	&help;
	exit 42;
}
if ($version) {
	&version;
	exit 42;
}

# time
my $current_time = time;
my $target_time  = $current_time - 300;

my $return_json = {
	data => {
		error             => 0,
		info              => 0,
		debug             => 0,
		warning           => 0,
		critical          => 0,
		banned            => 0,
		pending           => 0,
		running           => 0,
		completed         => 0,
		distributed       => 0,
		reported          => 0,
		recovered         => 0,
		failed_analysis   => 0,
		failed_processing => 0,
		failed_reporting  => 0,
	},
	error       => 0,
	errorString => '',
	version     => 1,
};

# used for checking if the level value is somethingw understand
my $level_check = { info => 1, debug => 1, error => 1, warning => 1, critical => 1 };

# read the config and put together the defaults
my $defaults = {
	dsn     => 'dbi:Pg:dbname=cape',
	user    => 'cape',
	pass    => '',
	clog    => '/opt/CAPEv2/log/cuckoo.log',
	plog    => '/opt/CAPEv2/log/process.log',
	mplogok => 1,
	ignores => '/usr/local/etc/cape_extend.ignores',
};
my $config = Config::Tiny->read( $ini_file, 'utf8' );
if ( !defined($config) ) {
	$config = $defaults;
}
else {
	$config = $config->{_};

	# reel in the defaults
	foreach my $default_key ( keys( %{$defaults} ) ) {
		if ( !defined( $config->{$default_key} ) ) {
			$config->{$default_key} = $defaults->{$default_key};
		}
	}
}

# read in the ignore file
my $ignores      = { info => [], debug => [], error => [], warning => [], critical => [] };
if ( -f $config->{ignores}) {
	my $ignore_raw   = read_file( $config->{ignores} );
	my @ignore_split = grep(/^[\ \t]*$/,grep( !/^[\ \t]*\#/, split( /\n/, $ignore_raw ) ));
	foreach my $to_ignore (@ignore_split) {
		my ( $ignore_level, $pattern ) = split( /[\ \t]+/, $to_ignore, 2 );
		if (defined($ignore_level) and defined($pattern)) {
			$ignore_level=lc($ignore_level);
			push(@{ $ignores->{$ignore_level} }, $pattern);
		}
	}
}

# put together the list of logs to read
my @logs;
if ( !-f $config->{clog} ) {
	$return_json->{error} = '"' . $defaults->{clog} . '" does not exist';
}
else {
	push( @logs, $config->{clog} );
}
if ( !-f $config->{plog} && !$config->{mplogok} ) {
	$return_json->{error} = '"' . $defaults->{clog} . '" does not exist';
}
else {
	push( @logs, $config->{plog} );
}

my $process_loop = 0;
my $process_logs = 1;
while ( $process_logs && defined( $logs[$process_loop] ) ) {
	my $log = $logs[$process_loop];

	my $bw = File::ReadBackwards->new($log);

	my $continue      = 1;
	my $current_entry = '';
	while ( defined( my $log_line = $bw->readline ) && $continue ) {
		$current_entry = $log_line . $current_entry;
		if ( $current_entry
			=~ /^20[0-9][0-9]\-[01][0-9]\-[0-3][0-9]\ [0-2][0-9]\:[0-5][0-9]\:[0-5][0-9]\,[0-9]+\ \[[a-z-A-Z\.0-9]+\]\ [a-zA-Z]+\:/
			)
		{
			# parse it and blank it for when we get to the next one.
			my ( $date, $time, $lib, $level, $entry ) = split( /[\ \t]+/, $current_entry );
			$current_entry = '';

			# chomp off the seconds place after the ,
			$time =~ s/\,.*//;
			my $t = Time::Piece->strptime( $date . 'T' . $time, '%Y-%m-%dT%H:%M:%S' );

			if ( $t->epoch <= $target_time ) {
				$continue = 0;
			}
			else {
				$level = lc($level);
				$level =~ s/\://;
				if ( defined( $level_check->{$level} ) ) {
					my $add_it     = 1;
					my $ignore_int = 0;
					while ( defined( $ignores->{$level} ) && defined( $ignores->{$level}->[$ignore_int] ) ) {
						my $test = $ignores->{$level}->[$ignore_int];
						if ( $entry =~ /$test/ ) {
							$add_it = 0;
						}
						if ($add_it) {
							$ignore_int++;
						}
					}
					$return_json->{data}->{$level}++;
				}
			}
		}
	}

	$process_loop++;
}

print encode_json($return_json)."\n";
